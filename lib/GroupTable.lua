---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by yemane.
--- DateTime: 3/4/2023 19:56
---
local _, ns = ...

--[[
  groups = { #: { #: <id>
                  idMap: { <id>: boolean }
           }
]]
---@class GroupTable
GroupTable = {}

---@return GroupTable new GroupTable object with groups
function GroupTable:New(groupsTable)
  local m = groupsTable or { groups = {} }
  setmetatable(m, self)
  self.__index = self
  return m
end

---@return table all groups in the group table
function GroupTable:GetGroups()
  return self.groups
end

---@return number index of added group
function GroupTable:AddGroup()
  table.insert(self.groups, {})
  local groupCount = #self.groups
  self.groups[groupCount].idMap = {}
  return groupCount
end

---@param index number index of group
---@return table group that was removed
function GroupTable:RemoveGroup(index)
  return table.remove(self.groups, index)
end

---@return number amount of groups
function GroupTable:GetCount()
  return #self.groups
end

---@param index number index of group
---@param id number macro id
---@return number index of added macro
function GroupTable:AddMacro(index, id)
  if index > #self.groups then error('index '..index..' is out of bounds') end

  local group = self.groups[index]
  if not group.idMap[id] then
    group.idMap[id] = true
    table.insert(group, id)
    table.sort(group)
    return #group
  end

  return nil
end

---@param index number index of group
---@return number amount of macros in group
function GroupTable:GetMacroCount(index)
  if not index then
    error('nil index provided')
  elseif index > #self.groups then
    error('index '..index..' is out of bounds')
  end
  return #self.groups[index]
end

---@param index number index of group
---@param macroIndex number index of macro
---@return number id of removed macro
function GroupTable:RemoveMacroAtIndex(index, macroIndex)
  local group = self.groups[index]
  local removedId = table.remove(group, macroIndex)
  group.idMap[removedId] = nil
  return removedId
end

---@param id number macro id
---@return
function GroupTable:RemoveMacro(id)
  for i, _ in ipairs(self.groups) do
    self:RemoveMacroFromGroup(i, id)
  end
end

local function isAccountMacro(id)
  return id <= MAX_ACCOUNT_MACROS and true or false
end

---@param index number index of group
---@param id number macro id
---@return
function GroupTable:RemoveMacroFromGroup(index, id)
  local group = self.groups[index]
  local foundIndex

  if group.idMap[id] then
    group.idMap[id] = nil

    for i, currentId in ipairs(group) do
      if foundIndex ~= nil then
        -- If the removed macro is the same type of macro (acct/char), decrement and update id map
        if (isAccountMacro(id) and isAccountMacro(currentId)) or (not isAccountMacro(id) and not isAccountMacro(currentId)) then
          group[i] = currentId - 1
          group.idMap[currentId] = nil
          group.idMap[currentId - 1] = true
        end
      end
      if currentId == id then
        foundIndex = i
      end
    end

    table.remove(group, foundIndex)
  end
end

---@param groupIndex number index of group
---@param macroIndex number index of macro in group
---@return number macro id
function GroupTable:GetMacroId(groupIndex, macroIndex)
  return self.groups[groupIndex][macroIndex]
end

